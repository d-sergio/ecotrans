Адаптивный слайдер



**********Особенности**********
-Бесконечная прокрутка
-Ширина адаптируется под родителя
-Высота адаптируется под контент
-Каждый слайд автоматически помещается в <div> (является flex)
одинаковой ширины (элементы frame в методе render). Слайд размещается
по центру горизонтальной оси <div>





**********Props**********
Значения по умолчанию:

initPosition: 0,    //Первоначальная позиция слайдера
visible: 1,     //см. ниже
adjacent: false,    //см. ниже
freeze: false,  //Отключить возможность прокрутки (также скроются кнопки прокрутки)
prev: null, //вид кнопки для прокрутки назад
next: null, //вид кнопки для прокрутки вперёд
duration: 500,  //длительность анимации для управления стрелками и клавиатурой в мс
treshold: 0.2,  //см. ниже
friction: 5,    //см. ниже
disableScrollingOn: 10, //см. ниже
autoMove: false,    //включить автопрокрутку карусели
cancelAutoMove: false,  //отключение автопрокрутки, если курсор над слайдером или произошло touch-событие
moveInterval: 3000, //интервал автопрокрутки в миллисекундах
callback: undefined //необязательный колбэк, который получает текущую позицию слайдера



visible не должен быть больше количества слайдов!

Может иметь значения:
   1. {Number} visible - количество одновременно видимых слайдов
   (1 по умолчанию).
   2. {Number} visible === 0 устанавливает автоматическое определение
   количества видимых слайдов на основе их размеров. Авто-visible работает
   только со слайдами фиксированной ширины.
   3. {Object} visible - например:
 
       {
           0: 1,    //Значение для 0px указывать всегда!
           768: 2,
           1024: 3,
           ...
       }

   Что значит:
       один слайд при размере окна >= 0px, 
       два слайда при размере окна >= 768px,
       три слайда при размере окна >= 1024px

adjacent - если true, то в свободное пространство viewport будут частично
попадать соседние слайды, находящиеся за границами viewport

_____________Слайдер_____________
...йд1] [слайд2] [слайд3] [сла...


treshold - значение от 0 до 1, указывающее, что слайд показавшийся больше,
чем на treshold при листании слайдера мышью или свайпами будет автоматически
вытянут до конца (0.2 по умолчанию)

friction - коэффициент трения для ленты слайдов. Чем больше значение, тем
быстрее карусель остановится при быстром прокручивании мышью или свайпами
(5 по умолчанию)

disableScrollingOn - для touch-событий. Если пользователь сдвинул карусель
больше, чем на указанное количество пикселей, то вертикальная прокрутка
страницы блокируется (10 по умолчанию). Можно отключить, указав
false/undefined/null





**********Параметр key**********
Во избежание багов, при изменении props слайдера, также следует изменять
его key, чтобы он был перерисован с учётом всех изменений





**********Настройка поведения прокрутки**********

Есть два варианта прокрутки слайдера с помощью мыши и свайпов:

1. Обычный (ordinary)
2. Инерционный (inertial)

Обычный подразумевает, что слайдер будет выставлен на той позиции,
на которой пользователь остановил движение курсора.
Инерционный означает, что слайдер будет учитывать скорость движения
курсора. Чем выше скорость, тем дальше слайдер прокрутит карусель,
когда пользователь отпустит кнопку мыши или сенсорный экран.

Для выбора поведения надо настроить следующие импорты в slider.js:

Обычное (ordinary)
import mouseHandler from './event-handlers/ordinary/mouse-handler';
import touchHandler from './event-handlers/ordinary/touch-handler';

Инерционное (inertial)
import mouseHandler from './event-handlers/inertial/mouse-handler';
import touchHandler from './event-handlers/inertial/touch-handler';





**********createParams()**********
В пропс есть только объект params со всеми настройками. Слайдер сразу
проверяет все ли поля в нём заполнены и добавляет дефолтные значения,
если необходимо. Внутри слайдера вся работа идёт уже не с props, а
с params




**********Алгоритм:**********

1. createSlides() создаёт слайды на рендере

2. Первый useEffect служит только для инициализации. Добавляет children
в params и задаёт геометрию слайдера через updateSlideWidth() и
updateCarouselCoords()

2. updateSlideWidth() задаёт ширину слайдов

3. updateCarouselCoords() уточняет координаты carousel, чтобы они
соответствовали текущей позиции currentPosition

4. Обработчик buttonHandler() сообщает в setNewPosition(), что позицию
слайдера необходимо сдвинуть на значение shift с использованием анимации
(на это указывает отличное от нуля значение animDuration)

5. setNewPosition() меняет позицию и добавляет/удаляет слайды слева или справа
по необходимости. По сути он создаёт условия для анимации, которая последует
за setState:
    - добавляются, если надо, новые слайды, чтобы всегда было куда прокручивать
    слайдер
    - с какой позиции надо будет прокручивать (state.prevState) и до какой
    позиции (state.currentPosition)
    - лишние слайды удаляются, чтобы не нагружать браузер

6. useEffect, обнаружив, что animDuration имеет отличное от нуля значение
запускает анимацию animateMove(). А перед этим, если были добавлены/удалены
слайды, корректирует геометрию слайдера, но устанавливает его в предыдущую
позицию, так как надо анимировать переход от неё к новой позиции.
    Если animDuration = 0, то без анимации слайдер просто переключается в
новую позицию.

7. animateMove() управляет анимацией:
    - останавливает текущую анимацию, если она осуществляется
    - передаёт в createAnimation() данные для расчёта анимации и получает оттуда
    объект анимации
    - запускает анимацию

8. createAnimation() создаёт и возвращает объект анимации

Метод getVisible() возвращает число видимы слайдов.

checkBounds() - если visible задан как {Object} или равен 0, то, если прокрутить
слайдер до конца, а затем растянуть окно так, чтобы число одновременно видимых
слайдов увеличилось, то последний слайд может съехать влево, оставив после себя
пустое пространство:

    visible === 2

   ____Слайдер____
   [слайд] [слайд]
 
Растягиваем окно и теперь visible === 3. Справа видим незаполненное слайдами
пространство

   __________Слайдер__________
   [слайд] [слайд] ...пусто...
 
 Данный метод исправляет это при необходимости.

Адаптивный слайдер

Особенности:
-Ширина адаптируется под родителя
-Высота адаптируется под контент
-Каждый слайд автоматически помещается в <div> (является flex)
одинаковой ширины (элементы frame в методе render). Слайд размещается
по центру горизонтальной оси <div>

Props

Все настройки помещаются в виде объекта в пропс params:

Создадим объект (в примере - значения по умолчанию)

params = {
    initPosition: 0,
    visible: 1,
    prev: <ArrowLeft/>,
    next: <ArrowRight/>,
    duration: 300,
    callback: undefined
}

<Slider params={params}><img.../><img.../><img.../></Slider>

Значения по умолчанию:

{
    initPosition: 0,    //Первоначальная позиция слайдера
    visible: 1, //см. ниже
    prev: null, //вид кнопки для прокрутки назад
    next: null, //вид кнопки для прокрутки вперёд
    duration: 500,  //длительность анимации для управления стрелками и клавиатурой в мс
    callback: undefined //необязательный колбэк, который получает текущую позицию слайдера
}

visible может иметь значения:
   1. {Number} visible - количество одновременно видимых слайдов
   (1 по умолчанию).
   2. {Number} visible === 0 устанавливает автоматическое определение
   количества видимых слайдов на основе их размеров. Авто-visible работает
   только со слайдами фиксированной ширины.
   3. {Object} visible - например:
 
       {
           0: 1,
           768: 2,
           1024: 3,
           ...
       }

   Что значит:
       один слайд при размере окна от 0px, 
       два слайда при размере окна от 768px,
       три слайда при размере окна от 1024px

   Значение для 0px желательно указывать всегда.


createParams()
В пропс есть только объект params со всеми настройками. Слайдер сразу
проверяет все ли поля в нём заполнены и добавляет дефолтные значения,
если необходимо. Внутри слайдера вся работа идёт уже не с props, а
с params

Алгоритм:

1. createSlides() создаёт слайды на рендере

2. Первый useEffect служит только для инициализации. Добавляет children
в params и задаёт геометрию слайдера через updateSlideWidth() и
updateCarouselCoords()

2. updateSlideWidth() задаёт ширину слайдов

3. updateCarouselCoords() уточняет координаты carousel, чтобы они
соответствовали текущей позиции currentPosition

4. Обработчик buttonHandler() сообщает в setNewPosition(), что позицию
слайдера необходимо сдвинуть на значение shift с использованием анимации
(на это указывает отличное от нуля значение animDuration)

5. setNewPosition() меняет позицию и добавляет/удаляет слайды слева или справа
по необходимости. По сути он создаёт условия для анимации, которая последует
за setState:
    - добавляются, если надо, новые слайды, чтобы всегда было куда прокручивать
    слайдер
    - с какой позиции надо будет прокручивать (state.prevState) и до какой
    позиции (state.currentPosition)
    - лишние слайды удаляются, чтобы не нагружать браузер

6. useEffect, обнаружив, что animDuration имеет отличное от нуля значение
запускает анимацию animateMove(). А перед этим, если были добавлены/удалены
слайды, корректирует геометрию слайдера, но устанавливает его в предыдущую
позицию, так как надо анимировать переход от неё к новой позиции.
    Если animDuration = 0, то без анимации слайдер просто переключается в
новую позицию.

7. animateMove() управляет анимацией:
    - останавливает текущую анимацию, если она осуществляется
    - передаёт в createAnimation() данные для расчёта анимации и получает оттуда
    объект анимации
    - запускает анимацию

8. createAnimation() создаёт и возвращает объект анимации

Метод getVisible() возвращает число видимы слайдов.
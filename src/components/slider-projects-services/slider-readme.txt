Адаптивный слайдер



**********Особенности**********
-Ширина адаптируется под родителя
-Высота адаптируется под контент
-Каждый слайд автоматически помещается в <div> (является flex)
одинаковой ширины (элементы frame в методе render). Слайд размещается
по центру горизонтальной оси <div>



**********Props**********

Все настройки помещаются в виде объекта в пропс params:

Создадим объект (в примере - значения по умолчанию)

params = {
    initPosition: 0,
    visible: 1,
    prev: <ArrowLeft/>,
    next: <ArrowRight/>,
    duration: 300,
    callback: undefined
}

<Slider params={params}><img.../><img.../><img.../></Slider>

Значения по умолчанию:

{
    initPosition: 0,    //Первоначальная позиция слайдера
    visible: 1, //см. ниже
    prev: null, //вид кнопки для прокрутки назад
    next: null, //вид кнопки для прокрутки вперёд
    duration: 500,  //длительность анимации для управления стрелками и клавиатурой в мс
    treshold: 0.2,  //см. ниже
    friction: 5,    //см. ниже
    disableScrollingOn: 10, //см. ниже
    motion: 'ordinary', //см. ниже
    callback: undefined //необязательный колбэк, который получает текущую позицию слайдера
}

visible может иметь значения:
   1. {Number} visible - количество одновременно видимых слайдов
   (1 по умолчанию).
   2. {Number} visible === 0 устанавливает автоматическое определение
   количества видимых слайдов на основе их размеров. Авто-visible работает
   только со слайдами фиксированной ширины.
   3. {Object} visible - например:
 
       {
           0: 1,
           768: 2,
           1024: 3,
           ...
       }

   Что значит:
       один слайд при размере окна от 0px, 
       два слайда при размере окна от 768px,
       три слайда при размере окна от 1024px

   Значение для 0px желательно указывать всегда.

treshold - значение от 0 до 1, указывающее, что слайд показавшийся больше,
чем на treshold при листании слайдера мышью или свайпами будет автоматически
вытянут до конца (0.2 по умолчанию)

friction - коэффициент трения для ленты слайдов. Чем больше значение, тем
быстрее карусель остановится при быстром прокручивании мышью или свайпами
(5 по умолчанию)

disableScrollingOn - для touch-событий. Если пользователь сдвинул карусель
больше, чем на указанное количество пикселей, то вертикальная прокрутка
страницы блокируется (10 по умолчанию). Можно отключить, указав
false/undefined/null

**********Настройка поведения прокрутки**********

Есть два варианта прокрутки слайдера с помощью мыши и свайпов:

1. Обычный (ordinary)
2. Инерционный (inertial)

Обычный подразумевает, что слайдер будет выставлен на той позиции,
на которой пользователь остановил движение курсора.
Инерционный означает, что слайдер будет учитывать скорость движения
курсора. Чем выше скорость, тем дальше слайдер прокрутит карусель,
когда пользователь отпустит кнопку мыши или сенсорный экран.

Для выбора поведения надо настроить следующие импорты в slider.js:

Обычное (ordinary)
import mouseHandler from './event-handlers/ordinary/mouse-handler';
import touchHandler from './event-handlers/ordinary/touch-handler';

Инерционное (inertial)
import mouseHandler from './event-handlers/inertial/mouse-handler';
import touchHandler from './event-handlers/inertial/touch-handler';



**********createParams()**********
В пропс есть только объект params со всеми настройками. Слайдер сразу
проверяет все ли поля в нём заполнены и добавляет дефолтные значения,
если необходимо. Внутри слайдера вся работа идёт уже не с props, а
с params


**********Алгоритм:**********

1. createSlides() создаёт слайды на рендере

2. Первый useEffect служит только для инициализации. Добавляет children
в params и задаёт геометрию слайдера через updateSlideWidth() и
updateCarouselCoords()

2. updateSlideWidth() задаёт ширину слайдов

3. updateCarouselCoords() уточняет координаты carousel, чтобы они
соответствовали текущей позиции currentPosition

4. Обработчик buttonHandler() сообщает в setNewPosition(), что позицию
слайдера необходимо сдвинуть на значение shift с использованием анимации
(на это указывает отличное от нуля значение animDuration)

5. setNewPosition() меняет позицию и добавляет/удаляет слайды слева или справа
по необходимости. По сути он создаёт условия для анимации, которая последует
за setState:
    - добавляются, если надо, новые слайды, чтобы всегда было куда прокручивать
    слайдер
    - с какой позиции надо будет прокручивать (state.prevState) и до какой
    позиции (state.currentPosition)
    - лишние слайды удаляются, чтобы не нагружать браузер

6. useEffect, обнаружив, что animDuration имеет отличное от нуля значение
запускает анимацию animateMove(). А перед этим, если были добавлены/удалены
слайды, корректирует геометрию слайдера, но устанавливает его в предыдущую
позицию, так как надо анимировать переход от неё к новой позиции.
    Если animDuration = 0, то без анимации слайдер просто переключается в
новую позицию.

7. animateMove() управляет анимацией:
    - останавливает текущую анимацию, если она осуществляется
    - передаёт в createAnimation() данные для расчёта анимации и получает оттуда
    объект анимации
    - запускает анимацию

8. createAnimation() создаёт и возвращает объект анимации

Метод getVisible() возвращает число видимы слайдов.